"""
AI Detection API endpoints with limits tracking.
"""

from typing import Annotated

from dishka import FromDishka
from dishka.integrations.fastapi import DishkaRoute
from fastapi import APIRouter, File, HTTPException, UploadFile, status, Depends

from src.api.v1.schemas.ai_detection import (
    AIDetectionResponse,
    DetectionResultSchema,
    DetectionSourceSchema,
    TextDetectionRequest,
)
from src.api.v1.schemas.limits import UserLimitsResponse
from src.core.logging import get_logger
from src.dtos import AuthenticatedUserDTO
from src.dtos.ai_detection_dto import DetectionResult, DetectionSource
from src.services.ai_detection_service import AIDetectionService
from src.services.shared.auth_helpers import get_authenticated_user_dependency

logger = get_logger(__name__)

router = APIRouter(
    prefix="/ai-detection",
    route_class=DishkaRoute,
    tags=["AI Detection"],
)


def _map_detection_result_to_schema(result: DetectionResult) -> DetectionResultSchema:
    """Map DTO DetectionResult to schema DetectionResultSchema."""
    mapping = {
        DetectionResult.AI_GENERATED: DetectionResultSchema.AI_GENERATED,
        DetectionResult.HUMAN_WRITTEN: DetectionResultSchema.HUMAN_WRITTEN,
        DetectionResult.UNCERTAIN: DetectionResultSchema.UNCERTAIN,
    }
    return mapping[result]


def _map_detection_source_to_schema(source: DetectionSource) -> DetectionSourceSchema:
    """Map DTO DetectionSource to schema DetectionSourceSchema."""
    mapping = {
        DetectionSource.TEXT: DetectionSourceSchema.TEXT,
        DetectionSource.FILE: DetectionSourceSchema.FILE,
    }
    return mapping[source]


class AIDetectionWithLimitsResponse(AIDetectionResponse):
    """Extended response with user limits."""
    limits: UserLimitsResponse


@router.post(
    "/detect-text",
    response_model=AIDetectionWithLimitsResponse,
    status_code=status.HTTP_200_OK,
    summary="Detect AI-generated text from input",
    description="Analyze provided text to determine if it was generated by AI or written by a human. Includes limit tracking.",
)
async def detect_from_text(
    request: TextDetectionRequest,
    service: FromDishka[AIDetectionService],
    current_user: Annotated[AuthenticatedUserDTO, Depends(get_authenticated_user_dependency)],
):
    """
    Detect if provided text is AI-generated or human-written.

    **Request Body:**
    - `text`: Text to analyze (minimum 50 characters)

    **Response:**
    - `result`: Detection result (ai_generated, human_written, or uncertain)
    - `confidence`: Confidence score between 0.0 and 1.0
    - `text_preview`: Preview of analyzed text
    - `source`: Always "text" for this endpoint
    - `metadata`: Additional information about the analysis
    - `limits`: Current user limits and usage

    **Limits:**
    - Free tier: 100 requests/day, 1000 requests/month
    - Premium: Higher limits (contact support)

    **Errors:**
    - 400: Invalid text (too short)
    - 429: Rate limit exceeded
    """
    try:
        logger.info(
            "detect_text_request",
            text_length=len(request.text),
            user_id=current_user.id,
            username=current_user.username
        )

        # Detect AI text (includes limit checking and history tracking)
        result_dto, limits_dto = await service.detect_from_text(
            text=request.text,
            user_id=current_user.id
        )

        # Map DTO to response schema
        response = AIDetectionWithLimitsResponse(
            result=_map_detection_result_to_schema(result_dto.result),
            confidence=result_dto.confidence,
            text_preview=result_dto.text_preview,
            source=_map_detection_source_to_schema(result_dto.source),
            file_name=result_dto.file_name,
            metadata=result_dto.metadata,
            limits=UserLimitsResponse(
                daily_limit=limits_dto.daily_limit,
                daily_used=limits_dto.daily_used,
                daily_remaining=limits_dto.daily_remaining,
                daily_reset_at=limits_dto.daily_reset_at,
                monthly_limit=limits_dto.monthly_limit,
                monthly_used=limits_dto.monthly_used,
                monthly_remaining=limits_dto.monthly_remaining,
                monthly_reset_at=limits_dto.monthly_reset_at,
                total_requests=limits_dto.total_requests,
                is_premium=limits_dto.is_premium,
                can_make_request=limits_dto.can_make_request
            )
        )

        logger.info(
            "detect_text_success",
            result=result_dto.result.value,
            confidence=result_dto.confidence,
            user_id=current_user.id,
            remaining_daily=limits_dto.daily_remaining,
            remaining_monthly=limits_dto.monthly_remaining
        )

        return response

    except ValueError as e:
        # Check if it's a limit error
        if "limit exceeded" in str(e).lower():
            logger.warning(
                "detect_text_limit_exceeded",
                error=str(e),
                user_id=current_user.id
            )
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail=str(e)
            )
        else:
            logger.warning(
                "detect_text_validation_error",
                error=str(e),
                user_id=current_user.id
            )
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(e)
            )
    except Exception as e:
        logger.error(
            "detect_text_failed",
            error=str(e),
            error_type=type(e).__name__,
            user_id=current_user.id,
            exc_info=True
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to detect AI text"
        )


@router.post(
    "/detect-file",
    response_model=AIDetectionWithLimitsResponse,
    status_code=status.HTTP_200_OK,
    summary="Detect AI-generated text from file",
    description="Upload a file to extract text and analyze if it was generated by AI. Includes limit tracking.",
)
async def detect_from_file(
    file: Annotated[UploadFile, File(description="File to analyze (PDF, DOCX, DOC, TXT)")],
    service: FromDishka[AIDetectionService],
    current_user: Annotated[AuthenticatedUserDTO, Depends(get_authenticated_user_dependency)],
):
    """
    Detect if text in uploaded file is AI-generated or human-written.

    **Supported File Types:**
    - PDF (.pdf)
    - Microsoft Word (.docx, .doc)
    - Plain Text (.txt)

    **File Requirements:**
    - Maximum size: 20MB
    - Must contain at least 50 characters of text

    **Process:**
    1. File is uploaded and validated
    2. Text is extracted using Google Gemini AI
    3. Extracted text is analyzed by ML model
    4. Detection result is returned with updated limits

    **Response:**
    - `result`: Detection result (ai_generated, human_written, or uncertain)
    - `confidence`: Confidence score between 0.0 and 1.0
    - `text_preview`: Preview of extracted text
    - `source`: Always "file" for this endpoint
    - `file_name`: Name of the uploaded file
    - `metadata`: File information and analysis details
    - `limits`: Current user limits and usage

    **Limits:**
    - Free tier: 100 requests/day, 1000 requests/month
    - Each file detection counts as 1 request

    **Errors:**
    - 400: Invalid file (wrong type, too large, insufficient text)
    - 429: Rate limit exceeded
    - 502: Text extraction service temporarily unavailable
    """
    try:
        logger.info(
            "detect_file_request",
            file_name=file.filename,
            content_type=file.content_type,
            user_id=current_user.id,
            username=current_user.username
        )

        # Read file content
        file_content = await file.read()

        if not file_content:
            raise ValueError("Uploaded file is empty")

        # Detect AI text from file (includes limit checking and history tracking)
        result_dto, limits_dto = await service.detect_from_file(
            file_content=file_content,
            file_name=file.filename or "unknown",
            content_type=file.content_type or "application/octet-stream",
            user_id=current_user.id
        )

        # Map DTO to response schema
        response = AIDetectionWithLimitsResponse(
            result=_map_detection_result_to_schema(result_dto.result),
            confidence=result_dto.confidence,
            text_preview=result_dto.text_preview,
            source=_map_detection_source_to_schema(result_dto.source),
            file_name=result_dto.file_name,
            metadata=result_dto.metadata,
            limits=UserLimitsResponse(
                daily_limit=limits_dto.daily_limit,
                daily_used=limits_dto.daily_used,
                daily_remaining=limits_dto.daily_remaining,
                daily_reset_at=limits_dto.daily_reset_at,
                monthly_limit=limits_dto.monthly_limit,
                monthly_used=limits_dto.monthly_used,
                monthly_remaining=limits_dto.monthly_remaining,
                monthly_reset_at=limits_dto.monthly_reset_at,
                total_requests=limits_dto.total_requests,
                is_premium=limits_dto.is_premium,
                can_make_request=limits_dto.can_make_request
            )
        )

        logger.info(
            "detect_file_success",
            file_name=file.filename,
            result=result_dto.result.value,
            confidence=result_dto.confidence,
            user_id=current_user.id,
            remaining_daily=limits_dto.daily_remaining,
            remaining_monthly=limits_dto.monthly_remaining
        )

        return response

    except ValueError as e:
        # Check if it's a limit error
        if "limit exceeded" in str(e).lower():
            logger.warning(
                "detect_file_limit_exceeded",
                file_name=file.filename,
                error=str(e),
                user_id=current_user.id
            )
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail=str(e)
            )
        else:
            logger.warning(
                "detect_file_validation_error",
                file_name=file.filename,
                error=str(e),
                user_id=current_user.id
            )
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(e)
            )
    except RuntimeError as e:
        logger.error(
            "detect_file_extraction_failed",
            file_name=file.filename,
            error=str(e),
            error_type=type(e).__name__,
            user_id=current_user.id,
            exc_info=True
        )
        raise HTTPException(
            status_code=status.HTTP_502_BAD_GATEWAY,
            detail="Text extraction service temporarily unavailable"
        )
    except Exception as e:
        logger.error(
            "detect_file_failed",
            file_name=file.filename,
            error=str(e),
            error_type=type(e).__name__,
            user_id=current_user.id,
            exc_info=True
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to detect AI text from file"
        )